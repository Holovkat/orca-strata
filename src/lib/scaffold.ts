import { mkdir, writeFile } from "fs/promises";
import { join } from "path";
import { spawn } from "child_process";
import type { OrcaConfig } from "./types.js";
import { DEFAULT_CONFIG } from "./types.js";

export interface ScaffoldResult {
  success: boolean;
  error?: string;
  path: string;
}

const README_TEMPLATE = (projectName: string) => `# ${projectName}

> Generated by Orca

## Overview

*This section will be populated from the PRD.*

## Getting Started

*Setup instructions will be added after architecture shard is complete.*

## Features

*Features will be documented as sprints are completed.*
`;

const PRD_TEMPLATE = `# Product Requirements Document

> This document defines the product vision, goals, and requirements.

## Project Description

*To be filled via PRD Q&A*

## Target Users

*To be filled via PRD Q&A*

## Problem Statement

*To be filled via PRD Q&A*

## Core Features (MVP)

*To be filled via PRD Q&A*

## Tech Stack

*To be filled via PRD Q&A*

## Constraints & Requirements

*To be filled via PRD Q&A*

---

## Sprint History

*Sprints will be logged here as they are completed.*
`;

const GITIGNORE_TEMPLATE = `# Dependencies
node_modules/

# Build output
dist/
out/
build/
.next/

# Environment
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Orca
.worktrees/

# Logs
*.log
logs/
`;

const ORCHESTRATOR_CONFIG = (projectName: string): Partial<OrcaConfig> => ({
  project_name: projectName,
  tracking: {
    mode: "local",
    backlog_board: "Backlog",
  },
  paths: {
    features: "features/",
    docs: "docs/design/",
    worktrees: ".worktrees/",
  },
  droids: {
    model: DEFAULT_CONFIG.droids.model,
    auto_level: "medium",
  },
  app_url: "http://localhost:3000",
  branching: {
    pattern: "feature/{sprint}-{shard}",
    stack_from: "previous",
  },
});

async function runCommand(cmd: string, args: string[], cwd: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const proc = spawn(cmd, args, { cwd, stdio: "pipe" });
    proc.on("close", (code) => {
      if (code === 0) resolve();
      else reject(new Error(`${cmd} ${args.join(" ")} failed with code ${code}`));
    });
    proc.on("error", reject);
  });
}

export async function scaffoldProject(
  projectPath: string,
  projectName: string
): Promise<ScaffoldResult> {
  try {
    // Create directory structure
    await mkdir(projectPath, { recursive: true });
    await mkdir(join(projectPath, "features", "sprints"), { recursive: true });
    await mkdir(join(projectPath, "docs", "design"), { recursive: true });
    await mkdir(join(projectPath, "src"), { recursive: true });

    // Create files
    await writeFile(
      join(projectPath, "README.md"),
      README_TEMPLATE(projectName)
    );
    
    await writeFile(
      join(projectPath, "features", "prd.md"),
      PRD_TEMPLATE
    );
    
    await writeFile(
      join(projectPath, ".gitignore"),
      GITIGNORE_TEMPLATE
    );
    
    await writeFile(
      join(projectPath, ".orchestrator.yaml"),
      `# Orca Orchestrator Configuration
project_name: "${projectName}"

tracking:
  mode: local
  backlog_board: Backlog

paths:
  features: features/
  docs: docs/design/
  worktrees: .worktrees/

droids:
  model: ${DEFAULT_CONFIG.droids.model}
  auto_level: medium

app_url: http://localhost:3000

branching:
  pattern: feature/{sprint}-{shard}
  stack_from: previous
`
    );

    // Create .gitkeep files for empty directories
    await writeFile(join(projectPath, "features", "sprints", ".gitkeep"), "");
    await writeFile(join(projectPath, "docs", "design", ".gitkeep"), "");
    await writeFile(join(projectPath, "src", ".gitkeep"), "");

    // Initialize git
    await runCommand("git", ["init"], projectPath);
    
    // Initial commit
    await runCommand("git", ["add", "-A"], projectPath);
    await runCommand("git", ["commit", "-m", "Initial project scaffold by Orca"], projectPath);

    return { success: true, path: projectPath };
  } catch (err) {
    return {
      success: false,
      error: err instanceof Error ? err.message : "Failed to scaffold project",
      path: projectPath,
    };
  }
}

export async function hasPrd(projectPath: string): Promise<boolean> {
  try {
    const { readFile } = await import("fs/promises");
    const prdPath = join(projectPath, "features", "prd.md");
    const content = await readFile(prdPath, "utf-8");
    // Check if PRD has been filled in (not just template)
    return !content.includes("*To be filled via PRD Q&A*");
  } catch {
    return false;
  }
}

export async function updatePrdFromAnswers(
  projectPath: string,
  answers: {
    projectDescription: string;
    targetUsers: string;
    problemSolved: string;
    coreFeatures: string;
    techStack: string;
    constraints: string;
  }
): Promise<void> {
  const prdContent = `# Product Requirements Document

> This document defines the product vision, goals, and requirements.

## Project Description

${answers.projectDescription}

## Target Users

${answers.targetUsers}

## Problem Statement

${answers.problemSolved}

## Core Features (MVP)

${answers.coreFeatures}

## Tech Stack

${answers.techStack}

## Constraints & Requirements

${answers.constraints}

---

## Sprint History

*Sprints will be logged here as they are completed.*
`;

  await writeFile(join(projectPath, "features", "prd.md"), prdContent);
}
